// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package vebo

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// ValidatorsExitBusOracleProcessingState is an auto generated low-level Go binding around an user-defined struct.
type ValidatorsExitBusOracleProcessingState struct {
	CurrentFrameRefSlot    *big.Int
	ProcessingDeadlineTime *big.Int
	DataHash               [32]byte
	DataSubmitted          bool
	DataFormat             *big.Int
	RequestsCount          *big.Int
	RequestsSubmitted      *big.Int
}

// ValidatorsExitBusOracleReportData is an auto generated low-level Go binding around an user-defined struct.
type ValidatorsExitBusOracleReportData struct {
	ConsensusVersion *big.Int
	RefSlot          *big.Int
	RequestsCount    *big.Int
	DataFormat       *big.Int
	Data             []byte
}

// VeboMetaData contains all meta data concerning the Vebo contract.
var VeboMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsPerSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"genesisTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lidoLocator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AddressCannotBeSame\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddressCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdminCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArgumentOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HashCannotBeZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialRefSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processingRefSlot\",\"type\":\"uint256\"}],\"name\":\"InitialRefSlotCannotBeLessThanProcessingOne\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidContractVersionIncrement\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRequestsData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRequestsDataLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRequestsDataSortOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoConsensusReportToProcess\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nodeOpId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevRequestedValidatorIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedValidatorIndex\",\"type\":\"uint256\"}],\"name\":\"NodeOpValidatorIndexMustIncrease\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonZeroContractVersionOnInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PauseUntilMustBeInFuture\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PausedExpected\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"ProcessingDeadlineMissed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RefSlotAlreadyProcessing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevRefSlot\",\"type\":\"uint256\"}],\"name\":\"RefSlotCannotDecrease\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processingRefSlot\",\"type\":\"uint256\"}],\"name\":\"RefSlotMustBeGreaterThanProcessingOne\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ResumedExpected\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SecondsPerSlotCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderIsNotTheConsensusContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnexpectedChainConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedVersion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedVersion\",\"type\":\"uint256\"}],\"name\":\"UnexpectedConsensusVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"UnexpectedContractVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"consensusHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"receivedHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedDataHash\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"consensusRefSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dataRefSlot\",\"type\":\"uint256\"}],\"name\":\"UnexpectedRefSlot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnexpectedRequestsDataLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"format\",\"type\":\"uint256\"}],\"name\":\"UnsupportedRequestsDataFormat\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VersionCannotBeSame\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroPauseDuration\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevAddr\",\"type\":\"address\"}],\"name\":\"ConsensusHashContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"prevVersion\",\"type\":\"uint256\"}],\"name\":\"ConsensusVersionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"ContractVersionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"ProcessingStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"ReportDiscarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"processingDeadlineTime\",\"type\":\"uint256\"}],\"name\":\"ReportSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Resumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakingModuleId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nodeOperatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"validatorPubkey\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ValidatorExitRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestsProcessed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestsCount\",\"type\":\"uint256\"}],\"name\":\"WarnDataIncompleteProcessing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"}],\"name\":\"WarnProcessingMissed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DATA_FORMAT_LIST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GENESIS_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGE_CONSENSUS_CONTRACT_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGE_CONSENSUS_VERSION_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSE_INFINITELY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESUME_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUBMIT_DATA_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"}],\"name\":\"discardConsensusReport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConsensusContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConsensusReport\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processingDeadlineTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"processingStarted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConsensusVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastProcessingRefSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nodeOpIds\",\"type\":\"uint256[]\"}],\"name\":\"getLastRequestedValidatorIndices\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProcessingState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"currentFrameRefSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"processingDeadlineTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"dataSubmitted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"dataFormat\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestsSubmitted\",\"type\":\"uint256\"}],\"internalType\":\"structValidatorsExitBusOracle.ProcessingState\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getResumeSinceTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRequestsProcessed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"consensusContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"consensusVersion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastProcessingRefSlot\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"pauseFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pauseUntilInclusive\",\"type\":\"uint256\"}],\"name\":\"pauseUntil\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setConsensusContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"setConsensusVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"reportHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"submitConsensusReport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"consensusVersion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dataFormat\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"structValidatorsExitBusOracle.ReportData\",\"name\":\"data\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"contractVersion\",\"type\":\"uint256\"}],\"name\":\"submitReportData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x608060405234801561001057600080fd5b50600436106102275760003560e01c80638f7797c211610130578063c469c307116100b8578063e2793e721161007c578063e2793e7214610538578063eb990c5914610540578063ef9bf37e14610553578063f288246114610573578063f3f449c71461059a57600080fd5b8063c469c307146104e4578063ca15c873146104f7578063d43812171461050a578063d547741f1461051d578063e271b7741461053057600080fd5b8063a217fddf116100ff578063a217fddf14610491578063a302ee3814610499578063abe9cfc8146104a2578063ad5cac4e146104b5578063b187bd26146104dc57600080fd5b80638f7797c2146103e45780639010d07c1461044457806391d14854146104575780639cc23c791461046a57600080fd5b806336568abe116101b35780635be20425116101825780635be204251461037757806360d64d381461037f5780638aa10435146103a95780638d591474146103b15780638f55b571146103c457600080fd5b806336568abe1461030e578063389ed2671461032157806346e1f57614610348578063589ff76c1461036f57600080fd5b8063294492c8116101fa578063294492c8146102925780632de03aa1146102a55780632f2ff15d146102cc578063304b9071146102df5780633584d59c1461030657600080fd5b806301ffc9a71461022c578063046f7da214610254578063063f36ad1461025e578063248a9ca314610271575b600080fd5b61023f61023a3660046126d4565b6105ad565b60405190151581526020015b60405180910390f35b61025c6105d8565b005b61025c61026c3660046126fe565b610616565b61028461027f36600461272a565b61080e565b60405190815260200161024b565b61025c6102a0366004612743565b610830565b6102847f2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c781565b61025c6102da3660046127a1565b610898565b6102847f000000000000000000000000000000000000000000000000000000000000000c81565b6102846108ba565b61025c61031c3660046127a1565b6108d7565b6102847f139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d81565b6102847f65fa0c17458517c727737e4153dd477fa3e328cf706640b0f68b1a285c5990da81565b610284610951565b610284610969565b610387610981565b604080519485526020850193909352918301521515606082015260800161024b565b610284610a29565b61025c6103bf36600461272a565b610a53565b6103cc610a87565b6040516001600160a01b03909116815260200161024b565b6103ec610a9f565b60405161024b9190600060e0820190508251825260208301516020830152604083015160408301526060830151151560608301526080830151608083015260a083015160a083015260c083015160c083015292915050565b6103cc6104523660046127d1565b610c36565b61023f6104653660046127a1565b610c62565b6102847fc31b1e4b732c5173dc51d519dfa432bad95550ecc4b0f9a61c2a558a2a8e434181565b610284600081565b61028460001981565b61025c6104b036600461272a565b610c9a565b6102847f04a0afbbd09d5ad397fc858789da4f8edd59f5ca5098d70faa490babee945c3b81565b61023f610cce565b61025c6104f23660046127f3565b610ced565b61028461050536600461272a565b610d37565b61025c61051836600461272a565b610d5b565b61025c61052b3660046127a1565b610e9e565b610284600181565b610284610ebb565b61025c61054e366004612810565b610ee5565b610566610561366004612856565b610f33565b60405161024b91906128d4565b6102847f0000000000000000000000000000000000000000000000000000000065156ac081565b61025c6105a836600461272a565b611093565b60006001600160e01b03198216635a05180f60e01b14806105d257506105d2826110cb565b92915050565b6105e0611100565b7f2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c761060b8133611127565b61061361118b565b50565b61061e6111cf565b600080516020612db0833981519152546001600160401b0316808310156106675760405163431d301760e11b815260048101849052602481018290526044015b60405180910390fd5b600061067f600080516020612d708339815191525490565b90508084116106ab576040516360a41e4960e01b8152600481018590526024810182905260440161065e565b824211156106cf5760405163537bacdf60e11b81526004810184905260240161065e565b8184141580156106df5750818114155b156107105760405182907f800b849c8bf80718cf786c99d1091c079fe2c5e420a3ba7ba9b0ef8179ef2c3890600090a25b8461072e57604051635b18a69f60e11b815260040160405180910390fd5b604080518681526020810185905285917faed7d1a7a1831158dcda1e4214f5862f450bd3eb5721a5f322bf8c9fe1790b0a910160405180910390a26000604051806060016040528087815260200161078587611210565b6001600160401b0316815260200161079c86611210565b6001600160401b039081169091528151600080516020612cd0833981519152556020820151600080516020612db0833981519152805460408501518416600160401b026001600160801b03199091169290931691909117919091179055905061080681848461127c565b505050505050565b6000908152600080516020612d50833981519152602052604090206001015490565b610838611366565b61084061138c565b610849816113e8565b61088282602001358360000135846040516020016108679190612941565b6040516020818303038152906040528051906020012061141e565b61088a61151d565b5061089482611643565b5050565b6108a18261080e565b6108ab8133611127565b6108b58383611947565b505050565b60006108d2600080516020612d708339815191525490565b905090565b6001600160a01b03811633146109475760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b606482015260840161065e565b6108948282611976565b60006108d2600080516020612d908339815191525490565b60006108d2600080516020612dd08339815191525490565b600080808080600080516020612cd083398151915260408051606081018252825481526001909201546001600160401b038082166020850152600160401b9091041690820152905060006109e1600080516020612d708339815191525490565b82516020840151604085015192935090918215801590610a0d57508385602001516001600160401b0316145b92996001600160401b0392831699509116965090945092505050565b60006108d27f4dd0f6662ba1d6b081f08b350f5e9a6a7b15cf586926ba66f753594928fa64a65490565b7fc31b1e4b732c5173dc51d519dfa432bad95550ecc4b0f9a61c2a558a2a8e4341610a7e8133611127565b610894826119a5565b60006108d2600080516020612d108339815191525490565b610ae46040518060e001604052806000815260200160008152602001600080191681526020016000151581526020016000815260200160008152602001600081525090565b60408051606081018252600080516020612cd0833981519152548152600080516020612db0833981519152546001600160401b038082166020840152600160401b9091041691810191909152610b38611a28565b825280511580610b59575080602001516001600160401b0316826000015114155b15610b62575090565b6040818101516001600160401b0316602084015281519083015260007ff54f01aac0787b485340ed16cefe4fba326c1674376c8dcd7c2a644b4643792f6040805160808101825291546001600160401b03808216808552600160401b830482166020860152600160801b830490911692840192909252600160c01b900461ffff166060808401919091528551909114908501819052909150610c0357505090565b606081015161ffff16608084015260208101516001600160401b0390811660a08501526040909101511660c08301525090565b6000828152600080516020612d3083398151915260205260408120610c5b9083611abd565b9392505050565b6000918252600080516020612d50833981519152602090815260408084206001600160a01b0393909316845291905290205460ff1690565b7f139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d610cc58133611127565b61089482611ac9565b6000610ce6600080516020612d908339815191525490565b4210905090565b7f04a0afbbd09d5ad397fc858789da4f8edd59f5ca5098d70faa490babee945c3b610d188133611127565b61089482610d32600080516020612d708339815191525490565b611b1d565b6000818152600080516020612d30833981519152602052604081206105d290611d76565b610d636111cf565b60408051606081018252600080516020612cd0833981519152548152600080516020612db0833981519152546001600160401b0380821660208401819052600160401b909204169282019290925290821015610dea57602081015160405163431d301760e11b8152600481018490526001600160401b03909116602482015260440161065e565b80602001516001600160401b0316821115610e03575050565b6000610e1b600080516020612d708339815191525490565b9050808311610e3c576040516252e2c960e41b815260040160405180910390fd5b6000600080516020612cd08339815191525581602001516001600160401b03167fe21266bc27ee721ac10034efaf7fd724656ef471c75b8402cd8f07850af6b6768360000151604051610e9191815260200190565b60405180910390a2505050565b610ea78261080e565b610eb18133611127565b6108b58383611976565b60006108d27f423c0a70d629d0b16eb0cfb674ba25f8352fe47057f0f4af829a850a22c6cc4a5490565b6001600160a01b038416610f0c57604051636b35b1b760e01b815260040160405180910390fd5b610f17600085611d80565b610f22600019611d8a565b610f2d838383611dda565b50505050565b606062ffffff841115610f5957604051632de932e560e01b815260040160405180910390fd5b6000826001600160401b03811115610f7357610f736129ca565b604051908082528060200260200182016040528015610f9c578160200160208202803683370190505b50905060005b8381101561108a576000858583818110610fbe57610fbe6129e0565b90506020020135905064ffffffffff8016811115610fef57604051632de932e560e01b815260040160405180910390fd5b602887901b81176000818152600080516020612cf0833981519152602090815260409182902082518084019093525460ff811615158084526101009091046001600160401b03169183019190915261104957600019611058565b80602001516001600160401b03165b85858151811061106a5761106a6129e0565b6020026020010181815250505050508061108390612a0c565b9050610fa2565b50949350505050565b7f139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d6110be8133611127565b61089482611d8a565b9055565b60006001600160e01b03198216637965db0b60e01b14806105d257506301ffc9a760e01b6001600160e01b03198316146105d2565b611108610cce565b6111255760405163b047186b60e01b815260040160405180910390fd5b565b6111318282610c62565b61089457611149816001600160a01b03166014611e4d565b611154836020611e4d565b604051602001611165929190612a53565b60408051601f198184030181529082905262461bcd60e51b825261065e91600401612ac8565b611193611100565b42600080516020612d90833981519152556040517f62451d457bc659158be6e6247f56ec1df424a5c7597f71c20c2bc44e0965c8f990600090a1565b600080516020612d10833981519152546001600160a01b0316336001600160a01b0316146111255760405163fef4d83160e01b815260040160405180910390fd5b60006001600160401b038211156112785760405162461bcd60e51b815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203660448201526534206269747360d01b606482015260840161065e565b5090565b604080516080810182527ff54f01aac0787b485340ed16cefe4fba326c1674376c8dcd7c2a644b4643792f546001600160401b03808216808452600160401b830482166020850152600160801b830490911693830193909352600160c01b900461ffff166060820152908214801561130d575080602001516001600160401b031681604001516001600160401b0316105b15610f2d5760408082015160208084015183516001600160401b03938416815292169082015283917fefc67aab43195093a8d8ed25d52281d96de480748ece2787888c586e8e1e79b4910160405180910390a250505050565b61136e610cce565b1561112557604051630286f07360e31b815260040160405180910390fd5b336113b77f65fa0c17458517c727737e4153dd477fa3e328cf706640b0f68b1a285c5990da82610c62565b1580156113ca57506113c881611fe8565b155b15610613576040516323dada5360e01b815260040160405180910390fd5b60006113f2610a29565b9050808214610894576040516303abe78360e21b8152600481018290526024810183905260440161065e565b60408051606081018252600080516020612cd0833981519152548152600080516020612db0833981519152546001600160401b0380821660208401819052600160401b90920416928201929092529084146114a457602081015160405163490b8d4560e11b81526001600160401b0390911660048201526024810185905260440161065e565b60006114bc600080516020612dd08339815191525490565b90508084146114e857604051632a37dd3d60e11b8152600481018290526024810185905260440161065e565b8151831461151657815160405163642c75c760e11b815260048101919091526024810184905260440161065e565b5050505050565b60408051606081018252600080516020612cd083398151915254808252600080516020612db0833981519152546001600160401b038082166020850152600160401b909104169282019290925260009161158a576040516364dfc18f60e01b815260040160405180910390fd5b6115a081604001516001600160401b031661207e565b60006115b8600080516020612d708339815191525490565b905081602001516001600160401b03168114156115e7576040516252e2c960e41b815260040160405180910390fd5b6020828101516001600160401b0316600080516020612d70833981519152819055835160405190815290917ff73febded7d4502284718948a3e1d75406151c6326bde069424a584a4f6af87a910160405180910390a292915050565b600181606001351461166e57604051630f542bef60e21b81526060820135600482015260240161065e565b604061167d6080830183612afb565b611688929150612b5e565b156116a657604051630260e4e160e41b815260040160405180910390fd5b7f00000000000000000000000028fab2059c713a7f9d8c86db49f9bb0e96af1ef86001600160a01b031663f5e6d50f6040518163ffffffff1660e01b815260040160206040518083038186803b1580156116ff57600080fd5b505afa158015611713573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117379190612b72565b6001600160a01b0316633e0865dd82604001356040518263ffffffff1660e01b815260040161176891815260200190565b60006040518083038186803b15801561178057600080fd5b505afa158015611794573d6000803e3d6000fd5b50505060408083013591506117ac6080840184612afb565b6117b7929150612b8f565b146117d55760405163f34afee160e01b815260040160405180910390fd5b6117ea6117e56080830183612afb565b6120a2565b60405180608001604052806118028360200135611210565b6001600160401b0316815260200161181d8360400135611210565b6001600160401b031681526020016118388360400135611210565b6001600160401b0316815260016020909101527ff54f01aac0787b485340ed16cefe4fba326c1674376c8dcd7c2a644b4643792f81518154602084015160408086015160609096015161ffff16600160c01b0261ffff60c01b196001600160401b03978816600160801b021669ffffffffffffffffffff60801b19938816600160401b026001600160801b031990951697909516969096179290921716919091179290921790558101356118e95750565b61061381604001356119197f423c0a70d629d0b16eb0cfb674ba25f8352fe47057f0f4af829a850a22c6cc4a5490565b6119239190612ba3565b7f423c0a70d629d0b16eb0cfb674ba25f8352fe47057f0f4af829a850a22c6cc4a55565b6119518282612339565b6000828152600080516020612d30833981519152602052604090206108b590826123af565b61198082826123c4565b6000828152600080516020612d30833981519152602052604090206108b59082612438565b60006119bd600080516020612dd08339815191525490565b9050808214156119e057604051631d7c761b60e21b815260040160405180910390fd5b6119f7600080516020612dd0833981519152839055565b604051819083907ffa5304972d4ec3e3207f0bbf91155a49d0dfa62488f9529403a2a49e4b29a89590600090a35050565b600080611a41600080516020612d108339815191525490565b90506000816001600160a01b03166372f79b136040518163ffffffff1660e01b8152600401604080518083038186803b158015611a7d57600080fd5b505afa158015611a91573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ab59190612bbb565b509392505050565b6000610c5b838361244d565b611ad1611366565b42811015611af2576040516339e2ec5360e11b815260040160405180910390fd5b60006000198214611b0f57611b08826001612ba3565b9050611b14565b506000195b61089481612477565b6001600160a01b038216611b44576040516303988b8160e61b815260040160405180910390fd5b6000611b5c600080516020612d108339815191525490565b9050806001600160a01b0316836001600160a01b03161415611b91576040516321a55ce160e11b815260040160405180910390fd5b600080846001600160a01b031663606c0c946040518163ffffffff1660e01b815260040160606040518083038186803b158015611bcd57600080fd5b505afa158015611be1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c059190612bdf565b92509250507f000000000000000000000000000000000000000000000000000000000000000c82141580611c5957507f0000000000000000000000000000000000000000000000000000000065156ac08114155b15611c7757604051635401d0a160e11b815260040160405180910390fd5b6000856001600160a01b0316636095012f6040518163ffffffff1660e01b815260040160206040518083038186803b158015611cb257600080fd5b505afa158015611cc6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cea9190612c0d565b905084811015611d1757604051631e779ad160e11b8152600481018290526024810186905260440161065e565b611d2e600080516020612d10833981519152879055565b836001600160a01b0316866001600160a01b03167f25421480fb7f52d18947876279a213696b58d7e0e5416ce5e2c9f9942661c34c60405160405180910390a3505050505050565b60006105d2825490565b6108948282611947565b611d92611366565b80611db05760405163ad58bfc760e01b815260040160405180910390fd5b6000600019821415611dc55750600019611b14565b611dcf8242612ba3565b905061089481612477565b611de4600161250a565b611dee8382611b1d565b611df7826119a5565b611e0e600080516020612d70833981519152829055565b611e1781611210565b600080516020612cd0833981519152600101805467ffffffffffffffff19166001600160401b0392909216919091179055505050565b60606000611e5c836002612c26565b611e67906002612ba3565b6001600160401b03811115611e7e57611e7e6129ca565b6040519080825280601f01601f191660200182016040528015611ea8576020820181803683370190505b509050600360fc1b81600081518110611ec357611ec36129e0565b60200101906001600160f81b031916908160001a905350600f60fb1b81600181518110611ef257611ef26129e0565b60200101906001600160f81b031916908160001a9053506000611f16846002612c26565b611f21906001612ba3565b90505b6001811115611f99576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110611f5557611f556129e0565b1a60f81b828281518110611f6b57611f6b6129e0565b60200101906001600160f81b031916908160001a90535060049490941c93611f9281612c45565b9050611f24565b508315610c5b5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e74604482015260640161065e565b600080612001600080516020612d108339815191525490565b604051631951c03760e01b81526001600160a01b03858116600483015291925090821690631951c0379060240160206040518083038186803b15801561204657600080fd5b505afa15801561205a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c5b9190612c5c565b804211156106135760405163537bacdf60e11b81526004810182905260240161065e565b60408051808201909152600080825260208201819052839183830191908190366030425b868810156122cb5760408801976010810193503560801c8681116120fd576040516362851b8960e01b815260040160405180910390fd5b8064ffffffffff604082901c1662ffffff606883901c1680612132576040516370180ea960e01b815260040160405180910390fd5b602881901b82178981146121eb5789156121a25788600080516020612cf083398151915260008c81526020918252604090208251815493909201516001600160401b03166101000268ffffffffffffffff00199215159290921668ffffffffffffffffff19909316929092171790555b6000818152600080516020612cf0833981519152602090815260409182902082518084019093525460ff81161515835261010090046001600160401b0316908201529099509750885b8851801561220f575088602001516001600160401b0316846001600160401b031611155b1561225457602089015160405163d4bb585960e01b815260048101849052602481018590526001600160401b039182166044820152908516606482015260840161065e565b6040518060400160405280600115158152602001856001600160401b03168152509850849a50836001600160401b031683837f96395f55c4997466e5035d777f0e1ba82b8cae217aaad05cf07839eb7c75bcf28b8b8b6040516122b993929190612c7e565b60405180910390a450505050506120c6565b841561232d5783600080516020612cf083398151915260008781526020918252604090208251815493909201516001600160401b03166101000268ffffffffffffffff00199215159290921668ffffffffffffffffff19909316929092171790555b50505050505050505050565b6123438282610c62565b610894576000828152600080516020612d50833981519152602090815260408083206001600160a01b0385168085529252808320805460ff1916600117905551339285917f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9190a45050565b6000610c5b836001600160a01b038416612539565b6123ce8282610c62565b15610894576000828152600080516020612d50833981519152602090815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b6000610c5b836001600160a01b038416612588565b6000826000018281548110612464576124646129e0565b9060005260206000200154905092915050565b61248e600080516020612d90833981519152829055565b6000198114156124d15760405160001981527f32fb7c9891bc4f963c7de9f1186d2a7755c7d6e9f4604dabe1d8bb3027c2f49e906020015b60405180910390a150565b7f32fb7c9891bc4f963c7de9f1186d2a7755c7d6e9f4604dabe1d8bb3027c2f49e6124fc4283612ca2565b6040519081526020016124c6565b612512610a29565b156125305760405163184e52a160e21b815260040160405180910390fd5b6106138161267b565b6000818152600183016020526040812054612580575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556105d2565b5060006105d2565b600081815260018301602052604081205480156126715760006125ac600183612ca2565b85549091506000906125c090600190612ca2565b90508181146126255760008660000182815481106125e0576125e06129e0565b9060005260206000200154905080876000018481548110612603576126036129e0565b6000918252602080832090910192909255918252600188019052604090208390555b855486908061263657612636612cb9565b6001900381819060005260206000200160009055905585600101600086815260200190815260200160002060009055600193505050506105d2565b60009150506105d2565b6126a47f4dd0f6662ba1d6b081f08b350f5e9a6a7b15cf586926ba66f753594928fa64a6829055565b6040518181527ffddcded6b4f4730c226821172046b48372d3cd963c159701ae1b7c3bcac541bb906020016124c6565b6000602082840312156126e657600080fd5b81356001600160e01b031981168114610c5b57600080fd5b60008060006060848603121561271357600080fd5b505081359360208301359350604090920135919050565b60006020828403121561273c57600080fd5b5035919050565b6000806040838503121561275657600080fd5b82356001600160401b0381111561276c57600080fd5b830160a0818603121561277e57600080fd5b946020939093013593505050565b6001600160a01b038116811461061357600080fd5b600080604083850312156127b457600080fd5b8235915060208301356127c68161278c565b809150509250929050565b600080604083850312156127e457600080fd5b50508035926020909101359150565b60006020828403121561280557600080fd5b8135610c5b8161278c565b6000806000806080858703121561282657600080fd5b84356128318161278c565b935060208501356128418161278c565b93969395505050506040820135916060013590565b60008060006040848603121561286b57600080fd5b8335925060208401356001600160401b038082111561288957600080fd5b818601915086601f83011261289d57600080fd5b8135818111156128ac57600080fd5b8760208260051b85010111156128c157600080fd5b6020830194508093505050509250925092565b6020808252825182820181905260009190848201906040850190845b8181101561290c578351835292840192918401916001016128f0565b50909695505050505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b602081528135602082015260208201356040820152604082013560608201526060820135608082015260006080830135601e1984360301811261298357600080fd5b830180356001600160401b0381111561299b57600080fd5b8036038513156129aa57600080fd5b60a0808501526129c160c085018260208501612918565b95945050505050565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600019821415612a2057612a206129f6565b5060010190565b60005b83811015612a42578181015183820152602001612a2a565b83811115610f2d5750506000910152565b7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000815260008351612a8b816017850160208801612a27565b7001034b99036b4b9b9b4b733903937b6329607d1b6017918401918201528351612abc816028840160208801612a27565b01602801949350505050565b6020815260008251806020840152612ae7816040850160208701612a27565b601f01601f19169190910160400192915050565b6000808335601e19843603018112612b1257600080fd5b8301803591506001600160401b03821115612b2c57600080fd5b602001915036819003821315612b4157600080fd5b9250929050565b634e487b7160e01b600052601260045260246000fd5b600082612b6d57612b6d612b48565b500690565b600060208284031215612b8457600080fd5b8151610c5b8161278c565b600082612b9e57612b9e612b48565b500490565b60008219821115612bb657612bb66129f6565b500190565b60008060408385031215612bce57600080fd5b505080516020909101519092909150565b600080600060608486031215612bf457600080fd5b8351925060208401519150604084015190509250925092565b600060208284031215612c1f57600080fd5b5051919050565b6000816000190483118215151615612c4057612c406129f6565b500290565b600081612c5457612c546129f6565b506000190190565b600060208284031215612c6e57600080fd5b81518015158114610c5b57600080fd5b604081526000612c92604083018587612918565b9050826020830152949350505050565b600082821015612cb457612cb46129f6565b500390565b634e487b7160e01b600052603160045260246000fdfe9d565e483b8608dc09e04eff85533859683d2eeaa6ebc28af53a92d7dba3eea6bd6f8054a60057d34b01ac26cf9ceebc52adc698c27460513794fb003b6529d6b0e01b719c2c32a677822ce1584cb6a66e576ee3c2c506b9621dbe626355aa658f8c450dae5029cd48cd91dd9db65da48fb742893edfc7941250f6721d93cbbe9a627a5d4aa7c17f87ff26e3fe9a42c2b6c559e8b41a42282d0ecebb17c0e4d3c9bdcd6eb2e956ecf03d8d27bee4c163f9b5c078aa69020d618e76513b5d0a94e8b012900cb200ee5dfc3b895a32791b67d12891b09f117814f167a237783a029d565e483b8608dc09e04eff85533859683d2eeaa6ebc28af53a92d7dba3eea72767d6892477f8d2750fb44e817c9aed93d34d3c6be4101ed58bcac692c99e9ca2646970667358221220ba9315d71daa9272447d2e1f7230a93aee14c04d44e36c5966ac2469f188463e64736f6c63430008090033",
}

// VeboABI is the input ABI used to generate the binding from.
// Deprecated: Use VeboMetaData.ABI instead.
var VeboABI = VeboMetaData.ABI

// VeboBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use VeboMetaData.Bin instead.
var VeboBin = VeboMetaData.Bin

// DeployVebo deploys a new Ethereum contract, binding an instance of Vebo to it.
func DeployVebo(auth *bind.TransactOpts, backend bind.ContractBackend, secondsPerSlot *big.Int, genesisTime *big.Int, lidoLocator common.Address) (common.Address, *types.Transaction, *Vebo, error) {
	parsed, err := VeboMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(VeboBin), backend, secondsPerSlot, genesisTime, lidoLocator)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Vebo{VeboCaller: VeboCaller{contract: contract}, VeboTransactor: VeboTransactor{contract: contract}, VeboFilterer: VeboFilterer{contract: contract}}, nil
}

// Vebo is an auto generated Go binding around an Ethereum contract.
type Vebo struct {
	VeboCaller     // Read-only binding to the contract
	VeboTransactor // Write-only binding to the contract
	VeboFilterer   // Log filterer for contract events
}

// VeboCaller is an auto generated read-only Go binding around an Ethereum contract.
type VeboCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VeboTransactor is an auto generated write-only Go binding around an Ethereum contract.
type VeboTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VeboFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type VeboFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VeboSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type VeboSession struct {
	Contract     *Vebo             // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// VeboCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type VeboCallerSession struct {
	Contract *VeboCaller   // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// VeboTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type VeboTransactorSession struct {
	Contract     *VeboTransactor   // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// VeboRaw is an auto generated low-level Go binding around an Ethereum contract.
type VeboRaw struct {
	Contract *Vebo // Generic contract binding to access the raw methods on
}

// VeboCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type VeboCallerRaw struct {
	Contract *VeboCaller // Generic read-only contract binding to access the raw methods on
}

// VeboTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type VeboTransactorRaw struct {
	Contract *VeboTransactor // Generic write-only contract binding to access the raw methods on
}

// NewVebo creates a new instance of Vebo, bound to a specific deployed contract.
func NewVebo(address common.Address, backend bind.ContractBackend) (*Vebo, error) {
	contract, err := bindVebo(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Vebo{VeboCaller: VeboCaller{contract: contract}, VeboTransactor: VeboTransactor{contract: contract}, VeboFilterer: VeboFilterer{contract: contract}}, nil
}

// NewVeboCaller creates a new read-only instance of Vebo, bound to a specific deployed contract.
func NewVeboCaller(address common.Address, caller bind.ContractCaller) (*VeboCaller, error) {
	contract, err := bindVebo(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &VeboCaller{contract: contract}, nil
}

// NewVeboTransactor creates a new write-only instance of Vebo, bound to a specific deployed contract.
func NewVeboTransactor(address common.Address, transactor bind.ContractTransactor) (*VeboTransactor, error) {
	contract, err := bindVebo(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &VeboTransactor{contract: contract}, nil
}

// NewVeboFilterer creates a new log filterer instance of Vebo, bound to a specific deployed contract.
func NewVeboFilterer(address common.Address, filterer bind.ContractFilterer) (*VeboFilterer, error) {
	contract, err := bindVebo(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &VeboFilterer{contract: contract}, nil
}

// bindVebo binds a generic wrapper to an already deployed contract.
func bindVebo(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := VeboMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Vebo *VeboRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Vebo.Contract.VeboCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Vebo *VeboRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Vebo.Contract.VeboTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Vebo *VeboRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Vebo.Contract.VeboTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Vebo *VeboCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Vebo.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Vebo *VeboTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Vebo.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Vebo *VeboTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Vebo.Contract.contract.Transact(opts, method, params...)
}

// DATAFORMATLIST is a free data retrieval call binding the contract method 0xe271b774.
//
// Solidity: function DATA_FORMAT_LIST() view returns(uint256)
func (_Vebo *VeboCaller) DATAFORMATLIST(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "DATA_FORMAT_LIST")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DATAFORMATLIST is a free data retrieval call binding the contract method 0xe271b774.
//
// Solidity: function DATA_FORMAT_LIST() view returns(uint256)
func (_Vebo *VeboSession) DATAFORMATLIST() (*big.Int, error) {
	return _Vebo.Contract.DATAFORMATLIST(&_Vebo.CallOpts)
}

// DATAFORMATLIST is a free data retrieval call binding the contract method 0xe271b774.
//
// Solidity: function DATA_FORMAT_LIST() view returns(uint256)
func (_Vebo *VeboCallerSession) DATAFORMATLIST() (*big.Int, error) {
	return _Vebo.Contract.DATAFORMATLIST(&_Vebo.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_Vebo *VeboCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_Vebo *VeboSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _Vebo.Contract.DEFAULTADMINROLE(&_Vebo.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_Vebo *VeboCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _Vebo.Contract.DEFAULTADMINROLE(&_Vebo.CallOpts)
}

// GENESISTIME is a free data retrieval call binding the contract method 0xf2882461.
//
// Solidity: function GENESIS_TIME() view returns(uint256)
func (_Vebo *VeboCaller) GENESISTIME(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "GENESIS_TIME")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GENESISTIME is a free data retrieval call binding the contract method 0xf2882461.
//
// Solidity: function GENESIS_TIME() view returns(uint256)
func (_Vebo *VeboSession) GENESISTIME() (*big.Int, error) {
	return _Vebo.Contract.GENESISTIME(&_Vebo.CallOpts)
}

// GENESISTIME is a free data retrieval call binding the contract method 0xf2882461.
//
// Solidity: function GENESIS_TIME() view returns(uint256)
func (_Vebo *VeboCallerSession) GENESISTIME() (*big.Int, error) {
	return _Vebo.Contract.GENESISTIME(&_Vebo.CallOpts)
}

// MANAGECONSENSUSCONTRACTROLE is a free data retrieval call binding the contract method 0xad5cac4e.
//
// Solidity: function MANAGE_CONSENSUS_CONTRACT_ROLE() view returns(bytes32)
func (_Vebo *VeboCaller) MANAGECONSENSUSCONTRACTROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "MANAGE_CONSENSUS_CONTRACT_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// MANAGECONSENSUSCONTRACTROLE is a free data retrieval call binding the contract method 0xad5cac4e.
//
// Solidity: function MANAGE_CONSENSUS_CONTRACT_ROLE() view returns(bytes32)
func (_Vebo *VeboSession) MANAGECONSENSUSCONTRACTROLE() ([32]byte, error) {
	return _Vebo.Contract.MANAGECONSENSUSCONTRACTROLE(&_Vebo.CallOpts)
}

// MANAGECONSENSUSCONTRACTROLE is a free data retrieval call binding the contract method 0xad5cac4e.
//
// Solidity: function MANAGE_CONSENSUS_CONTRACT_ROLE() view returns(bytes32)
func (_Vebo *VeboCallerSession) MANAGECONSENSUSCONTRACTROLE() ([32]byte, error) {
	return _Vebo.Contract.MANAGECONSENSUSCONTRACTROLE(&_Vebo.CallOpts)
}

// MANAGECONSENSUSVERSIONROLE is a free data retrieval call binding the contract method 0x9cc23c79.
//
// Solidity: function MANAGE_CONSENSUS_VERSION_ROLE() view returns(bytes32)
func (_Vebo *VeboCaller) MANAGECONSENSUSVERSIONROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "MANAGE_CONSENSUS_VERSION_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// MANAGECONSENSUSVERSIONROLE is a free data retrieval call binding the contract method 0x9cc23c79.
//
// Solidity: function MANAGE_CONSENSUS_VERSION_ROLE() view returns(bytes32)
func (_Vebo *VeboSession) MANAGECONSENSUSVERSIONROLE() ([32]byte, error) {
	return _Vebo.Contract.MANAGECONSENSUSVERSIONROLE(&_Vebo.CallOpts)
}

// MANAGECONSENSUSVERSIONROLE is a free data retrieval call binding the contract method 0x9cc23c79.
//
// Solidity: function MANAGE_CONSENSUS_VERSION_ROLE() view returns(bytes32)
func (_Vebo *VeboCallerSession) MANAGECONSENSUSVERSIONROLE() ([32]byte, error) {
	return _Vebo.Contract.MANAGECONSENSUSVERSIONROLE(&_Vebo.CallOpts)
}

// PAUSEINFINITELY is a free data retrieval call binding the contract method 0xa302ee38.
//
// Solidity: function PAUSE_INFINITELY() view returns(uint256)
func (_Vebo *VeboCaller) PAUSEINFINITELY(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "PAUSE_INFINITELY")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// PAUSEINFINITELY is a free data retrieval call binding the contract method 0xa302ee38.
//
// Solidity: function PAUSE_INFINITELY() view returns(uint256)
func (_Vebo *VeboSession) PAUSEINFINITELY() (*big.Int, error) {
	return _Vebo.Contract.PAUSEINFINITELY(&_Vebo.CallOpts)
}

// PAUSEINFINITELY is a free data retrieval call binding the contract method 0xa302ee38.
//
// Solidity: function PAUSE_INFINITELY() view returns(uint256)
func (_Vebo *VeboCallerSession) PAUSEINFINITELY() (*big.Int, error) {
	return _Vebo.Contract.PAUSEINFINITELY(&_Vebo.CallOpts)
}

// PAUSEROLE is a free data retrieval call binding the contract method 0x389ed267.
//
// Solidity: function PAUSE_ROLE() view returns(bytes32)
func (_Vebo *VeboCaller) PAUSEROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "PAUSE_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// PAUSEROLE is a free data retrieval call binding the contract method 0x389ed267.
//
// Solidity: function PAUSE_ROLE() view returns(bytes32)
func (_Vebo *VeboSession) PAUSEROLE() ([32]byte, error) {
	return _Vebo.Contract.PAUSEROLE(&_Vebo.CallOpts)
}

// PAUSEROLE is a free data retrieval call binding the contract method 0x389ed267.
//
// Solidity: function PAUSE_ROLE() view returns(bytes32)
func (_Vebo *VeboCallerSession) PAUSEROLE() ([32]byte, error) {
	return _Vebo.Contract.PAUSEROLE(&_Vebo.CallOpts)
}

// RESUMEROLE is a free data retrieval call binding the contract method 0x2de03aa1.
//
// Solidity: function RESUME_ROLE() view returns(bytes32)
func (_Vebo *VeboCaller) RESUMEROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "RESUME_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// RESUMEROLE is a free data retrieval call binding the contract method 0x2de03aa1.
//
// Solidity: function RESUME_ROLE() view returns(bytes32)
func (_Vebo *VeboSession) RESUMEROLE() ([32]byte, error) {
	return _Vebo.Contract.RESUMEROLE(&_Vebo.CallOpts)
}

// RESUMEROLE is a free data retrieval call binding the contract method 0x2de03aa1.
//
// Solidity: function RESUME_ROLE() view returns(bytes32)
func (_Vebo *VeboCallerSession) RESUMEROLE() ([32]byte, error) {
	return _Vebo.Contract.RESUMEROLE(&_Vebo.CallOpts)
}

// SECONDSPERSLOT is a free data retrieval call binding the contract method 0x304b9071.
//
// Solidity: function SECONDS_PER_SLOT() view returns(uint256)
func (_Vebo *VeboCaller) SECONDSPERSLOT(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "SECONDS_PER_SLOT")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SECONDSPERSLOT is a free data retrieval call binding the contract method 0x304b9071.
//
// Solidity: function SECONDS_PER_SLOT() view returns(uint256)
func (_Vebo *VeboSession) SECONDSPERSLOT() (*big.Int, error) {
	return _Vebo.Contract.SECONDSPERSLOT(&_Vebo.CallOpts)
}

// SECONDSPERSLOT is a free data retrieval call binding the contract method 0x304b9071.
//
// Solidity: function SECONDS_PER_SLOT() view returns(uint256)
func (_Vebo *VeboCallerSession) SECONDSPERSLOT() (*big.Int, error) {
	return _Vebo.Contract.SECONDSPERSLOT(&_Vebo.CallOpts)
}

// SUBMITDATAROLE is a free data retrieval call binding the contract method 0x46e1f576.
//
// Solidity: function SUBMIT_DATA_ROLE() view returns(bytes32)
func (_Vebo *VeboCaller) SUBMITDATAROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "SUBMIT_DATA_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SUBMITDATAROLE is a free data retrieval call binding the contract method 0x46e1f576.
//
// Solidity: function SUBMIT_DATA_ROLE() view returns(bytes32)
func (_Vebo *VeboSession) SUBMITDATAROLE() ([32]byte, error) {
	return _Vebo.Contract.SUBMITDATAROLE(&_Vebo.CallOpts)
}

// SUBMITDATAROLE is a free data retrieval call binding the contract method 0x46e1f576.
//
// Solidity: function SUBMIT_DATA_ROLE() view returns(bytes32)
func (_Vebo *VeboCallerSession) SUBMITDATAROLE() ([32]byte, error) {
	return _Vebo.Contract.SUBMITDATAROLE(&_Vebo.CallOpts)
}

// GetConsensusContract is a free data retrieval call binding the contract method 0x8f55b571.
//
// Solidity: function getConsensusContract() view returns(address)
func (_Vebo *VeboCaller) GetConsensusContract(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getConsensusContract")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetConsensusContract is a free data retrieval call binding the contract method 0x8f55b571.
//
// Solidity: function getConsensusContract() view returns(address)
func (_Vebo *VeboSession) GetConsensusContract() (common.Address, error) {
	return _Vebo.Contract.GetConsensusContract(&_Vebo.CallOpts)
}

// GetConsensusContract is a free data retrieval call binding the contract method 0x8f55b571.
//
// Solidity: function getConsensusContract() view returns(address)
func (_Vebo *VeboCallerSession) GetConsensusContract() (common.Address, error) {
	return _Vebo.Contract.GetConsensusContract(&_Vebo.CallOpts)
}

// GetConsensusReport is a free data retrieval call binding the contract method 0x60d64d38.
//
// Solidity: function getConsensusReport() view returns(bytes32 hash, uint256 refSlot, uint256 processingDeadlineTime, bool processingStarted)
func (_Vebo *VeboCaller) GetConsensusReport(opts *bind.CallOpts) (struct {
	Hash                   [32]byte
	RefSlot                *big.Int
	ProcessingDeadlineTime *big.Int
	ProcessingStarted      bool
}, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getConsensusReport")

	outstruct := new(struct {
		Hash                   [32]byte
		RefSlot                *big.Int
		ProcessingDeadlineTime *big.Int
		ProcessingStarted      bool
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Hash = *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)
	outstruct.RefSlot = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.ProcessingDeadlineTime = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.ProcessingStarted = *abi.ConvertType(out[3], new(bool)).(*bool)

	return *outstruct, err

}

// GetConsensusReport is a free data retrieval call binding the contract method 0x60d64d38.
//
// Solidity: function getConsensusReport() view returns(bytes32 hash, uint256 refSlot, uint256 processingDeadlineTime, bool processingStarted)
func (_Vebo *VeboSession) GetConsensusReport() (struct {
	Hash                   [32]byte
	RefSlot                *big.Int
	ProcessingDeadlineTime *big.Int
	ProcessingStarted      bool
}, error) {
	return _Vebo.Contract.GetConsensusReport(&_Vebo.CallOpts)
}

// GetConsensusReport is a free data retrieval call binding the contract method 0x60d64d38.
//
// Solidity: function getConsensusReport() view returns(bytes32 hash, uint256 refSlot, uint256 processingDeadlineTime, bool processingStarted)
func (_Vebo *VeboCallerSession) GetConsensusReport() (struct {
	Hash                   [32]byte
	RefSlot                *big.Int
	ProcessingDeadlineTime *big.Int
	ProcessingStarted      bool
}, error) {
	return _Vebo.Contract.GetConsensusReport(&_Vebo.CallOpts)
}

// GetConsensusVersion is a free data retrieval call binding the contract method 0x5be20425.
//
// Solidity: function getConsensusVersion() view returns(uint256)
func (_Vebo *VeboCaller) GetConsensusVersion(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getConsensusVersion")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetConsensusVersion is a free data retrieval call binding the contract method 0x5be20425.
//
// Solidity: function getConsensusVersion() view returns(uint256)
func (_Vebo *VeboSession) GetConsensusVersion() (*big.Int, error) {
	return _Vebo.Contract.GetConsensusVersion(&_Vebo.CallOpts)
}

// GetConsensusVersion is a free data retrieval call binding the contract method 0x5be20425.
//
// Solidity: function getConsensusVersion() view returns(uint256)
func (_Vebo *VeboCallerSession) GetConsensusVersion() (*big.Int, error) {
	return _Vebo.Contract.GetConsensusVersion(&_Vebo.CallOpts)
}

// GetContractVersion is a free data retrieval call binding the contract method 0x8aa10435.
//
// Solidity: function getContractVersion() view returns(uint256)
func (_Vebo *VeboCaller) GetContractVersion(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getContractVersion")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetContractVersion is a free data retrieval call binding the contract method 0x8aa10435.
//
// Solidity: function getContractVersion() view returns(uint256)
func (_Vebo *VeboSession) GetContractVersion() (*big.Int, error) {
	return _Vebo.Contract.GetContractVersion(&_Vebo.CallOpts)
}

// GetContractVersion is a free data retrieval call binding the contract method 0x8aa10435.
//
// Solidity: function getContractVersion() view returns(uint256)
func (_Vebo *VeboCallerSession) GetContractVersion() (*big.Int, error) {
	return _Vebo.Contract.GetContractVersion(&_Vebo.CallOpts)
}

// GetLastProcessingRefSlot is a free data retrieval call binding the contract method 0x3584d59c.
//
// Solidity: function getLastProcessingRefSlot() view returns(uint256)
func (_Vebo *VeboCaller) GetLastProcessingRefSlot(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getLastProcessingRefSlot")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetLastProcessingRefSlot is a free data retrieval call binding the contract method 0x3584d59c.
//
// Solidity: function getLastProcessingRefSlot() view returns(uint256)
func (_Vebo *VeboSession) GetLastProcessingRefSlot() (*big.Int, error) {
	return _Vebo.Contract.GetLastProcessingRefSlot(&_Vebo.CallOpts)
}

// GetLastProcessingRefSlot is a free data retrieval call binding the contract method 0x3584d59c.
//
// Solidity: function getLastProcessingRefSlot() view returns(uint256)
func (_Vebo *VeboCallerSession) GetLastProcessingRefSlot() (*big.Int, error) {
	return _Vebo.Contract.GetLastProcessingRefSlot(&_Vebo.CallOpts)
}

// GetLastRequestedValidatorIndices is a free data retrieval call binding the contract method 0xef9bf37e.
//
// Solidity: function getLastRequestedValidatorIndices(uint256 moduleId, uint256[] nodeOpIds) view returns(int256[])
func (_Vebo *VeboCaller) GetLastRequestedValidatorIndices(opts *bind.CallOpts, moduleId *big.Int, nodeOpIds []*big.Int) ([]*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getLastRequestedValidatorIndices", moduleId, nodeOpIds)

	if err != nil {
		return *new([]*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new([]*big.Int)).(*[]*big.Int)

	return out0, err

}

// GetLastRequestedValidatorIndices is a free data retrieval call binding the contract method 0xef9bf37e.
//
// Solidity: function getLastRequestedValidatorIndices(uint256 moduleId, uint256[] nodeOpIds) view returns(int256[])
func (_Vebo *VeboSession) GetLastRequestedValidatorIndices(moduleId *big.Int, nodeOpIds []*big.Int) ([]*big.Int, error) {
	return _Vebo.Contract.GetLastRequestedValidatorIndices(&_Vebo.CallOpts, moduleId, nodeOpIds)
}

// GetLastRequestedValidatorIndices is a free data retrieval call binding the contract method 0xef9bf37e.
//
// Solidity: function getLastRequestedValidatorIndices(uint256 moduleId, uint256[] nodeOpIds) view returns(int256[])
func (_Vebo *VeboCallerSession) GetLastRequestedValidatorIndices(moduleId *big.Int, nodeOpIds []*big.Int) ([]*big.Int, error) {
	return _Vebo.Contract.GetLastRequestedValidatorIndices(&_Vebo.CallOpts, moduleId, nodeOpIds)
}

// GetProcessingState is a free data retrieval call binding the contract method 0x8f7797c2.
//
// Solidity: function getProcessingState() view returns((uint256,uint256,bytes32,bool,uint256,uint256,uint256) result)
func (_Vebo *VeboCaller) GetProcessingState(opts *bind.CallOpts) (ValidatorsExitBusOracleProcessingState, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getProcessingState")

	if err != nil {
		return *new(ValidatorsExitBusOracleProcessingState), err
	}

	out0 := *abi.ConvertType(out[0], new(ValidatorsExitBusOracleProcessingState)).(*ValidatorsExitBusOracleProcessingState)

	return out0, err

}

// GetProcessingState is a free data retrieval call binding the contract method 0x8f7797c2.
//
// Solidity: function getProcessingState() view returns((uint256,uint256,bytes32,bool,uint256,uint256,uint256) result)
func (_Vebo *VeboSession) GetProcessingState() (ValidatorsExitBusOracleProcessingState, error) {
	return _Vebo.Contract.GetProcessingState(&_Vebo.CallOpts)
}

// GetProcessingState is a free data retrieval call binding the contract method 0x8f7797c2.
//
// Solidity: function getProcessingState() view returns((uint256,uint256,bytes32,bool,uint256,uint256,uint256) result)
func (_Vebo *VeboCallerSession) GetProcessingState() (ValidatorsExitBusOracleProcessingState, error) {
	return _Vebo.Contract.GetProcessingState(&_Vebo.CallOpts)
}

// GetResumeSinceTimestamp is a free data retrieval call binding the contract method 0x589ff76c.
//
// Solidity: function getResumeSinceTimestamp() view returns(uint256)
func (_Vebo *VeboCaller) GetResumeSinceTimestamp(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getResumeSinceTimestamp")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetResumeSinceTimestamp is a free data retrieval call binding the contract method 0x589ff76c.
//
// Solidity: function getResumeSinceTimestamp() view returns(uint256)
func (_Vebo *VeboSession) GetResumeSinceTimestamp() (*big.Int, error) {
	return _Vebo.Contract.GetResumeSinceTimestamp(&_Vebo.CallOpts)
}

// GetResumeSinceTimestamp is a free data retrieval call binding the contract method 0x589ff76c.
//
// Solidity: function getResumeSinceTimestamp() view returns(uint256)
func (_Vebo *VeboCallerSession) GetResumeSinceTimestamp() (*big.Int, error) {
	return _Vebo.Contract.GetResumeSinceTimestamp(&_Vebo.CallOpts)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_Vebo *VeboCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_Vebo *VeboSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _Vebo.Contract.GetRoleAdmin(&_Vebo.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_Vebo *VeboCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _Vebo.Contract.GetRoleAdmin(&_Vebo.CallOpts, role)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_Vebo *VeboCaller) GetRoleMember(opts *bind.CallOpts, role [32]byte, index *big.Int) (common.Address, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getRoleMember", role, index)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_Vebo *VeboSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _Vebo.Contract.GetRoleMember(&_Vebo.CallOpts, role, index)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_Vebo *VeboCallerSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _Vebo.Contract.GetRoleMember(&_Vebo.CallOpts, role, index)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_Vebo *VeboCaller) GetRoleMemberCount(opts *bind.CallOpts, role [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getRoleMemberCount", role)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_Vebo *VeboSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _Vebo.Contract.GetRoleMemberCount(&_Vebo.CallOpts, role)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_Vebo *VeboCallerSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _Vebo.Contract.GetRoleMemberCount(&_Vebo.CallOpts, role)
}

// GetTotalRequestsProcessed is a free data retrieval call binding the contract method 0xe2793e72.
//
// Solidity: function getTotalRequestsProcessed() view returns(uint256)
func (_Vebo *VeboCaller) GetTotalRequestsProcessed(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "getTotalRequestsProcessed")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetTotalRequestsProcessed is a free data retrieval call binding the contract method 0xe2793e72.
//
// Solidity: function getTotalRequestsProcessed() view returns(uint256)
func (_Vebo *VeboSession) GetTotalRequestsProcessed() (*big.Int, error) {
	return _Vebo.Contract.GetTotalRequestsProcessed(&_Vebo.CallOpts)
}

// GetTotalRequestsProcessed is a free data retrieval call binding the contract method 0xe2793e72.
//
// Solidity: function getTotalRequestsProcessed() view returns(uint256)
func (_Vebo *VeboCallerSession) GetTotalRequestsProcessed() (*big.Int, error) {
	return _Vebo.Contract.GetTotalRequestsProcessed(&_Vebo.CallOpts)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_Vebo *VeboCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_Vebo *VeboSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _Vebo.Contract.HasRole(&_Vebo.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_Vebo *VeboCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _Vebo.Contract.HasRole(&_Vebo.CallOpts, role, account)
}

// IsPaused is a free data retrieval call binding the contract method 0xb187bd26.
//
// Solidity: function isPaused() view returns(bool)
func (_Vebo *VeboCaller) IsPaused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "isPaused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPaused is a free data retrieval call binding the contract method 0xb187bd26.
//
// Solidity: function isPaused() view returns(bool)
func (_Vebo *VeboSession) IsPaused() (bool, error) {
	return _Vebo.Contract.IsPaused(&_Vebo.CallOpts)
}

// IsPaused is a free data retrieval call binding the contract method 0xb187bd26.
//
// Solidity: function isPaused() view returns(bool)
func (_Vebo *VeboCallerSession) IsPaused() (bool, error) {
	return _Vebo.Contract.IsPaused(&_Vebo.CallOpts)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_Vebo *VeboCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _Vebo.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_Vebo *VeboSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _Vebo.Contract.SupportsInterface(&_Vebo.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_Vebo *VeboCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _Vebo.Contract.SupportsInterface(&_Vebo.CallOpts, interfaceId)
}

// DiscardConsensusReport is a paid mutator transaction binding the contract method 0xd4381217.
//
// Solidity: function discardConsensusReport(uint256 refSlot) returns()
func (_Vebo *VeboTransactor) DiscardConsensusReport(opts *bind.TransactOpts, refSlot *big.Int) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "discardConsensusReport", refSlot)
}

// DiscardConsensusReport is a paid mutator transaction binding the contract method 0xd4381217.
//
// Solidity: function discardConsensusReport(uint256 refSlot) returns()
func (_Vebo *VeboSession) DiscardConsensusReport(refSlot *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.DiscardConsensusReport(&_Vebo.TransactOpts, refSlot)
}

// DiscardConsensusReport is a paid mutator transaction binding the contract method 0xd4381217.
//
// Solidity: function discardConsensusReport(uint256 refSlot) returns()
func (_Vebo *VeboTransactorSession) DiscardConsensusReport(refSlot *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.DiscardConsensusReport(&_Vebo.TransactOpts, refSlot)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_Vebo *VeboTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_Vebo *VeboSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Vebo.Contract.GrantRole(&_Vebo.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_Vebo *VeboTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Vebo.Contract.GrantRole(&_Vebo.TransactOpts, role, account)
}

// Initialize is a paid mutator transaction binding the contract method 0xeb990c59.
//
// Solidity: function initialize(address admin, address consensusContract, uint256 consensusVersion, uint256 lastProcessingRefSlot) returns()
func (_Vebo *VeboTransactor) Initialize(opts *bind.TransactOpts, admin common.Address, consensusContract common.Address, consensusVersion *big.Int, lastProcessingRefSlot *big.Int) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "initialize", admin, consensusContract, consensusVersion, lastProcessingRefSlot)
}

// Initialize is a paid mutator transaction binding the contract method 0xeb990c59.
//
// Solidity: function initialize(address admin, address consensusContract, uint256 consensusVersion, uint256 lastProcessingRefSlot) returns()
func (_Vebo *VeboSession) Initialize(admin common.Address, consensusContract common.Address, consensusVersion *big.Int, lastProcessingRefSlot *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.Initialize(&_Vebo.TransactOpts, admin, consensusContract, consensusVersion, lastProcessingRefSlot)
}

// Initialize is a paid mutator transaction binding the contract method 0xeb990c59.
//
// Solidity: function initialize(address admin, address consensusContract, uint256 consensusVersion, uint256 lastProcessingRefSlot) returns()
func (_Vebo *VeboTransactorSession) Initialize(admin common.Address, consensusContract common.Address, consensusVersion *big.Int, lastProcessingRefSlot *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.Initialize(&_Vebo.TransactOpts, admin, consensusContract, consensusVersion, lastProcessingRefSlot)
}

// PauseFor is a paid mutator transaction binding the contract method 0xf3f449c7.
//
// Solidity: function pauseFor(uint256 _duration) returns()
func (_Vebo *VeboTransactor) PauseFor(opts *bind.TransactOpts, _duration *big.Int) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "pauseFor", _duration)
}

// PauseFor is a paid mutator transaction binding the contract method 0xf3f449c7.
//
// Solidity: function pauseFor(uint256 _duration) returns()
func (_Vebo *VeboSession) PauseFor(_duration *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.PauseFor(&_Vebo.TransactOpts, _duration)
}

// PauseFor is a paid mutator transaction binding the contract method 0xf3f449c7.
//
// Solidity: function pauseFor(uint256 _duration) returns()
func (_Vebo *VeboTransactorSession) PauseFor(_duration *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.PauseFor(&_Vebo.TransactOpts, _duration)
}

// PauseUntil is a paid mutator transaction binding the contract method 0xabe9cfc8.
//
// Solidity: function pauseUntil(uint256 _pauseUntilInclusive) returns()
func (_Vebo *VeboTransactor) PauseUntil(opts *bind.TransactOpts, _pauseUntilInclusive *big.Int) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "pauseUntil", _pauseUntilInclusive)
}

// PauseUntil is a paid mutator transaction binding the contract method 0xabe9cfc8.
//
// Solidity: function pauseUntil(uint256 _pauseUntilInclusive) returns()
func (_Vebo *VeboSession) PauseUntil(_pauseUntilInclusive *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.PauseUntil(&_Vebo.TransactOpts, _pauseUntilInclusive)
}

// PauseUntil is a paid mutator transaction binding the contract method 0xabe9cfc8.
//
// Solidity: function pauseUntil(uint256 _pauseUntilInclusive) returns()
func (_Vebo *VeboTransactorSession) PauseUntil(_pauseUntilInclusive *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.PauseUntil(&_Vebo.TransactOpts, _pauseUntilInclusive)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_Vebo *VeboTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_Vebo *VeboSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Vebo.Contract.RenounceRole(&_Vebo.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_Vebo *VeboTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Vebo.Contract.RenounceRole(&_Vebo.TransactOpts, role, account)
}

// Resume is a paid mutator transaction binding the contract method 0x046f7da2.
//
// Solidity: function resume() returns()
func (_Vebo *VeboTransactor) Resume(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "resume")
}

// Resume is a paid mutator transaction binding the contract method 0x046f7da2.
//
// Solidity: function resume() returns()
func (_Vebo *VeboSession) Resume() (*types.Transaction, error) {
	return _Vebo.Contract.Resume(&_Vebo.TransactOpts)
}

// Resume is a paid mutator transaction binding the contract method 0x046f7da2.
//
// Solidity: function resume() returns()
func (_Vebo *VeboTransactorSession) Resume() (*types.Transaction, error) {
	return _Vebo.Contract.Resume(&_Vebo.TransactOpts)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_Vebo *VeboTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_Vebo *VeboSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Vebo.Contract.RevokeRole(&_Vebo.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_Vebo *VeboTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _Vebo.Contract.RevokeRole(&_Vebo.TransactOpts, role, account)
}

// SetConsensusContract is a paid mutator transaction binding the contract method 0xc469c307.
//
// Solidity: function setConsensusContract(address addr) returns()
func (_Vebo *VeboTransactor) SetConsensusContract(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "setConsensusContract", addr)
}

// SetConsensusContract is a paid mutator transaction binding the contract method 0xc469c307.
//
// Solidity: function setConsensusContract(address addr) returns()
func (_Vebo *VeboSession) SetConsensusContract(addr common.Address) (*types.Transaction, error) {
	return _Vebo.Contract.SetConsensusContract(&_Vebo.TransactOpts, addr)
}

// SetConsensusContract is a paid mutator transaction binding the contract method 0xc469c307.
//
// Solidity: function setConsensusContract(address addr) returns()
func (_Vebo *VeboTransactorSession) SetConsensusContract(addr common.Address) (*types.Transaction, error) {
	return _Vebo.Contract.SetConsensusContract(&_Vebo.TransactOpts, addr)
}

// SetConsensusVersion is a paid mutator transaction binding the contract method 0x8d591474.
//
// Solidity: function setConsensusVersion(uint256 version) returns()
func (_Vebo *VeboTransactor) SetConsensusVersion(opts *bind.TransactOpts, version *big.Int) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "setConsensusVersion", version)
}

// SetConsensusVersion is a paid mutator transaction binding the contract method 0x8d591474.
//
// Solidity: function setConsensusVersion(uint256 version) returns()
func (_Vebo *VeboSession) SetConsensusVersion(version *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.SetConsensusVersion(&_Vebo.TransactOpts, version)
}

// SetConsensusVersion is a paid mutator transaction binding the contract method 0x8d591474.
//
// Solidity: function setConsensusVersion(uint256 version) returns()
func (_Vebo *VeboTransactorSession) SetConsensusVersion(version *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.SetConsensusVersion(&_Vebo.TransactOpts, version)
}

// SubmitConsensusReport is a paid mutator transaction binding the contract method 0x063f36ad.
//
// Solidity: function submitConsensusReport(bytes32 reportHash, uint256 refSlot, uint256 deadline) returns()
func (_Vebo *VeboTransactor) SubmitConsensusReport(opts *bind.TransactOpts, reportHash [32]byte, refSlot *big.Int, deadline *big.Int) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "submitConsensusReport", reportHash, refSlot, deadline)
}

// SubmitConsensusReport is a paid mutator transaction binding the contract method 0x063f36ad.
//
// Solidity: function submitConsensusReport(bytes32 reportHash, uint256 refSlot, uint256 deadline) returns()
func (_Vebo *VeboSession) SubmitConsensusReport(reportHash [32]byte, refSlot *big.Int, deadline *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.SubmitConsensusReport(&_Vebo.TransactOpts, reportHash, refSlot, deadline)
}

// SubmitConsensusReport is a paid mutator transaction binding the contract method 0x063f36ad.
//
// Solidity: function submitConsensusReport(bytes32 reportHash, uint256 refSlot, uint256 deadline) returns()
func (_Vebo *VeboTransactorSession) SubmitConsensusReport(reportHash [32]byte, refSlot *big.Int, deadline *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.SubmitConsensusReport(&_Vebo.TransactOpts, reportHash, refSlot, deadline)
}

// SubmitReportData is a paid mutator transaction binding the contract method 0x294492c8.
//
// Solidity: function submitReportData((uint256,uint256,uint256,uint256,bytes) data, uint256 contractVersion) returns()
func (_Vebo *VeboTransactor) SubmitReportData(opts *bind.TransactOpts, data ValidatorsExitBusOracleReportData, contractVersion *big.Int) (*types.Transaction, error) {
	return _Vebo.contract.Transact(opts, "submitReportData", data, contractVersion)
}

// SubmitReportData is a paid mutator transaction binding the contract method 0x294492c8.
//
// Solidity: function submitReportData((uint256,uint256,uint256,uint256,bytes) data, uint256 contractVersion) returns()
func (_Vebo *VeboSession) SubmitReportData(data ValidatorsExitBusOracleReportData, contractVersion *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.SubmitReportData(&_Vebo.TransactOpts, data, contractVersion)
}

// SubmitReportData is a paid mutator transaction binding the contract method 0x294492c8.
//
// Solidity: function submitReportData((uint256,uint256,uint256,uint256,bytes) data, uint256 contractVersion) returns()
func (_Vebo *VeboTransactorSession) SubmitReportData(data ValidatorsExitBusOracleReportData, contractVersion *big.Int) (*types.Transaction, error) {
	return _Vebo.Contract.SubmitReportData(&_Vebo.TransactOpts, data, contractVersion)
}

// VeboConsensusHashContractSetIterator is returned from FilterConsensusHashContractSet and is used to iterate over the raw logs and unpacked data for ConsensusHashContractSet events raised by the Vebo contract.
type VeboConsensusHashContractSetIterator struct {
	Event *VeboConsensusHashContractSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboConsensusHashContractSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboConsensusHashContractSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboConsensusHashContractSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboConsensusHashContractSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboConsensusHashContractSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboConsensusHashContractSet represents a ConsensusHashContractSet event raised by the Vebo contract.
type VeboConsensusHashContractSet struct {
	Addr     common.Address
	PrevAddr common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterConsensusHashContractSet is a free log retrieval operation binding the contract event 0x25421480fb7f52d18947876279a213696b58d7e0e5416ce5e2c9f9942661c34c.
//
// Solidity: event ConsensusHashContractSet(address indexed addr, address indexed prevAddr)
func (_Vebo *VeboFilterer) FilterConsensusHashContractSet(opts *bind.FilterOpts, addr []common.Address, prevAddr []common.Address) (*VeboConsensusHashContractSetIterator, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var prevAddrRule []interface{}
	for _, prevAddrItem := range prevAddr {
		prevAddrRule = append(prevAddrRule, prevAddrItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "ConsensusHashContractSet", addrRule, prevAddrRule)
	if err != nil {
		return nil, err
	}
	return &VeboConsensusHashContractSetIterator{contract: _Vebo.contract, event: "ConsensusHashContractSet", logs: logs, sub: sub}, nil
}

// WatchConsensusHashContractSet is a free log subscription operation binding the contract event 0x25421480fb7f52d18947876279a213696b58d7e0e5416ce5e2c9f9942661c34c.
//
// Solidity: event ConsensusHashContractSet(address indexed addr, address indexed prevAddr)
func (_Vebo *VeboFilterer) WatchConsensusHashContractSet(opts *bind.WatchOpts, sink chan<- *VeboConsensusHashContractSet, addr []common.Address, prevAddr []common.Address) (event.Subscription, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var prevAddrRule []interface{}
	for _, prevAddrItem := range prevAddr {
		prevAddrRule = append(prevAddrRule, prevAddrItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "ConsensusHashContractSet", addrRule, prevAddrRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboConsensusHashContractSet)
				if err := _Vebo.contract.UnpackLog(event, "ConsensusHashContractSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseConsensusHashContractSet is a log parse operation binding the contract event 0x25421480fb7f52d18947876279a213696b58d7e0e5416ce5e2c9f9942661c34c.
//
// Solidity: event ConsensusHashContractSet(address indexed addr, address indexed prevAddr)
func (_Vebo *VeboFilterer) ParseConsensusHashContractSet(log types.Log) (*VeboConsensusHashContractSet, error) {
	event := new(VeboConsensusHashContractSet)
	if err := _Vebo.contract.UnpackLog(event, "ConsensusHashContractSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboConsensusVersionSetIterator is returned from FilterConsensusVersionSet and is used to iterate over the raw logs and unpacked data for ConsensusVersionSet events raised by the Vebo contract.
type VeboConsensusVersionSetIterator struct {
	Event *VeboConsensusVersionSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboConsensusVersionSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboConsensusVersionSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboConsensusVersionSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboConsensusVersionSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboConsensusVersionSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboConsensusVersionSet represents a ConsensusVersionSet event raised by the Vebo contract.
type VeboConsensusVersionSet struct {
	Version     *big.Int
	PrevVersion *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterConsensusVersionSet is a free log retrieval operation binding the contract event 0xfa5304972d4ec3e3207f0bbf91155a49d0dfa62488f9529403a2a49e4b29a895.
//
// Solidity: event ConsensusVersionSet(uint256 indexed version, uint256 indexed prevVersion)
func (_Vebo *VeboFilterer) FilterConsensusVersionSet(opts *bind.FilterOpts, version []*big.Int, prevVersion []*big.Int) (*VeboConsensusVersionSetIterator, error) {

	var versionRule []interface{}
	for _, versionItem := range version {
		versionRule = append(versionRule, versionItem)
	}
	var prevVersionRule []interface{}
	for _, prevVersionItem := range prevVersion {
		prevVersionRule = append(prevVersionRule, prevVersionItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "ConsensusVersionSet", versionRule, prevVersionRule)
	if err != nil {
		return nil, err
	}
	return &VeboConsensusVersionSetIterator{contract: _Vebo.contract, event: "ConsensusVersionSet", logs: logs, sub: sub}, nil
}

// WatchConsensusVersionSet is a free log subscription operation binding the contract event 0xfa5304972d4ec3e3207f0bbf91155a49d0dfa62488f9529403a2a49e4b29a895.
//
// Solidity: event ConsensusVersionSet(uint256 indexed version, uint256 indexed prevVersion)
func (_Vebo *VeboFilterer) WatchConsensusVersionSet(opts *bind.WatchOpts, sink chan<- *VeboConsensusVersionSet, version []*big.Int, prevVersion []*big.Int) (event.Subscription, error) {

	var versionRule []interface{}
	for _, versionItem := range version {
		versionRule = append(versionRule, versionItem)
	}
	var prevVersionRule []interface{}
	for _, prevVersionItem := range prevVersion {
		prevVersionRule = append(prevVersionRule, prevVersionItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "ConsensusVersionSet", versionRule, prevVersionRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboConsensusVersionSet)
				if err := _Vebo.contract.UnpackLog(event, "ConsensusVersionSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseConsensusVersionSet is a log parse operation binding the contract event 0xfa5304972d4ec3e3207f0bbf91155a49d0dfa62488f9529403a2a49e4b29a895.
//
// Solidity: event ConsensusVersionSet(uint256 indexed version, uint256 indexed prevVersion)
func (_Vebo *VeboFilterer) ParseConsensusVersionSet(log types.Log) (*VeboConsensusVersionSet, error) {
	event := new(VeboConsensusVersionSet)
	if err := _Vebo.contract.UnpackLog(event, "ConsensusVersionSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboContractVersionSetIterator is returned from FilterContractVersionSet and is used to iterate over the raw logs and unpacked data for ContractVersionSet events raised by the Vebo contract.
type VeboContractVersionSetIterator struct {
	Event *VeboContractVersionSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboContractVersionSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboContractVersionSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboContractVersionSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboContractVersionSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboContractVersionSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboContractVersionSet represents a ContractVersionSet event raised by the Vebo contract.
type VeboContractVersionSet struct {
	Version *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterContractVersionSet is a free log retrieval operation binding the contract event 0xfddcded6b4f4730c226821172046b48372d3cd963c159701ae1b7c3bcac541bb.
//
// Solidity: event ContractVersionSet(uint256 version)
func (_Vebo *VeboFilterer) FilterContractVersionSet(opts *bind.FilterOpts) (*VeboContractVersionSetIterator, error) {

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "ContractVersionSet")
	if err != nil {
		return nil, err
	}
	return &VeboContractVersionSetIterator{contract: _Vebo.contract, event: "ContractVersionSet", logs: logs, sub: sub}, nil
}

// WatchContractVersionSet is a free log subscription operation binding the contract event 0xfddcded6b4f4730c226821172046b48372d3cd963c159701ae1b7c3bcac541bb.
//
// Solidity: event ContractVersionSet(uint256 version)
func (_Vebo *VeboFilterer) WatchContractVersionSet(opts *bind.WatchOpts, sink chan<- *VeboContractVersionSet) (event.Subscription, error) {

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "ContractVersionSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboContractVersionSet)
				if err := _Vebo.contract.UnpackLog(event, "ContractVersionSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseContractVersionSet is a log parse operation binding the contract event 0xfddcded6b4f4730c226821172046b48372d3cd963c159701ae1b7c3bcac541bb.
//
// Solidity: event ContractVersionSet(uint256 version)
func (_Vebo *VeboFilterer) ParseContractVersionSet(log types.Log) (*VeboContractVersionSet, error) {
	event := new(VeboContractVersionSet)
	if err := _Vebo.contract.UnpackLog(event, "ContractVersionSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the Vebo contract.
type VeboPausedIterator struct {
	Event *VeboPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboPaused represents a Paused event raised by the Vebo contract.
type VeboPaused struct {
	Duration *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x32fb7c9891bc4f963c7de9f1186d2a7755c7d6e9f4604dabe1d8bb3027c2f49e.
//
// Solidity: event Paused(uint256 duration)
func (_Vebo *VeboFilterer) FilterPaused(opts *bind.FilterOpts) (*VeboPausedIterator, error) {

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &VeboPausedIterator{contract: _Vebo.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x32fb7c9891bc4f963c7de9f1186d2a7755c7d6e9f4604dabe1d8bb3027c2f49e.
//
// Solidity: event Paused(uint256 duration)
func (_Vebo *VeboFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *VeboPaused) (event.Subscription, error) {

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboPaused)
				if err := _Vebo.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x32fb7c9891bc4f963c7de9f1186d2a7755c7d6e9f4604dabe1d8bb3027c2f49e.
//
// Solidity: event Paused(uint256 duration)
func (_Vebo *VeboFilterer) ParsePaused(log types.Log) (*VeboPaused, error) {
	event := new(VeboPaused)
	if err := _Vebo.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboProcessingStartedIterator is returned from FilterProcessingStarted and is used to iterate over the raw logs and unpacked data for ProcessingStarted events raised by the Vebo contract.
type VeboProcessingStartedIterator struct {
	Event *VeboProcessingStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboProcessingStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboProcessingStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboProcessingStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboProcessingStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboProcessingStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboProcessingStarted represents a ProcessingStarted event raised by the Vebo contract.
type VeboProcessingStarted struct {
	RefSlot *big.Int
	Hash    [32]byte
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterProcessingStarted is a free log retrieval operation binding the contract event 0xf73febded7d4502284718948a3e1d75406151c6326bde069424a584a4f6af87a.
//
// Solidity: event ProcessingStarted(uint256 indexed refSlot, bytes32 hash)
func (_Vebo *VeboFilterer) FilterProcessingStarted(opts *bind.FilterOpts, refSlot []*big.Int) (*VeboProcessingStartedIterator, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "ProcessingStarted", refSlotRule)
	if err != nil {
		return nil, err
	}
	return &VeboProcessingStartedIterator{contract: _Vebo.contract, event: "ProcessingStarted", logs: logs, sub: sub}, nil
}

// WatchProcessingStarted is a free log subscription operation binding the contract event 0xf73febded7d4502284718948a3e1d75406151c6326bde069424a584a4f6af87a.
//
// Solidity: event ProcessingStarted(uint256 indexed refSlot, bytes32 hash)
func (_Vebo *VeboFilterer) WatchProcessingStarted(opts *bind.WatchOpts, sink chan<- *VeboProcessingStarted, refSlot []*big.Int) (event.Subscription, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "ProcessingStarted", refSlotRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboProcessingStarted)
				if err := _Vebo.contract.UnpackLog(event, "ProcessingStarted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProcessingStarted is a log parse operation binding the contract event 0xf73febded7d4502284718948a3e1d75406151c6326bde069424a584a4f6af87a.
//
// Solidity: event ProcessingStarted(uint256 indexed refSlot, bytes32 hash)
func (_Vebo *VeboFilterer) ParseProcessingStarted(log types.Log) (*VeboProcessingStarted, error) {
	event := new(VeboProcessingStarted)
	if err := _Vebo.contract.UnpackLog(event, "ProcessingStarted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboReportDiscardedIterator is returned from FilterReportDiscarded and is used to iterate over the raw logs and unpacked data for ReportDiscarded events raised by the Vebo contract.
type VeboReportDiscardedIterator struct {
	Event *VeboReportDiscarded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboReportDiscardedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboReportDiscarded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboReportDiscarded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboReportDiscardedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboReportDiscardedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboReportDiscarded represents a ReportDiscarded event raised by the Vebo contract.
type VeboReportDiscarded struct {
	RefSlot *big.Int
	Hash    [32]byte
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterReportDiscarded is a free log retrieval operation binding the contract event 0xe21266bc27ee721ac10034efaf7fd724656ef471c75b8402cd8f07850af6b676.
//
// Solidity: event ReportDiscarded(uint256 indexed refSlot, bytes32 hash)
func (_Vebo *VeboFilterer) FilterReportDiscarded(opts *bind.FilterOpts, refSlot []*big.Int) (*VeboReportDiscardedIterator, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "ReportDiscarded", refSlotRule)
	if err != nil {
		return nil, err
	}
	return &VeboReportDiscardedIterator{contract: _Vebo.contract, event: "ReportDiscarded", logs: logs, sub: sub}, nil
}

// WatchReportDiscarded is a free log subscription operation binding the contract event 0xe21266bc27ee721ac10034efaf7fd724656ef471c75b8402cd8f07850af6b676.
//
// Solidity: event ReportDiscarded(uint256 indexed refSlot, bytes32 hash)
func (_Vebo *VeboFilterer) WatchReportDiscarded(opts *bind.WatchOpts, sink chan<- *VeboReportDiscarded, refSlot []*big.Int) (event.Subscription, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "ReportDiscarded", refSlotRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboReportDiscarded)
				if err := _Vebo.contract.UnpackLog(event, "ReportDiscarded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseReportDiscarded is a log parse operation binding the contract event 0xe21266bc27ee721ac10034efaf7fd724656ef471c75b8402cd8f07850af6b676.
//
// Solidity: event ReportDiscarded(uint256 indexed refSlot, bytes32 hash)
func (_Vebo *VeboFilterer) ParseReportDiscarded(log types.Log) (*VeboReportDiscarded, error) {
	event := new(VeboReportDiscarded)
	if err := _Vebo.contract.UnpackLog(event, "ReportDiscarded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboReportSubmittedIterator is returned from FilterReportSubmitted and is used to iterate over the raw logs and unpacked data for ReportSubmitted events raised by the Vebo contract.
type VeboReportSubmittedIterator struct {
	Event *VeboReportSubmitted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboReportSubmittedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboReportSubmitted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboReportSubmitted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboReportSubmittedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboReportSubmittedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboReportSubmitted represents a ReportSubmitted event raised by the Vebo contract.
type VeboReportSubmitted struct {
	RefSlot                *big.Int
	Hash                   [32]byte
	ProcessingDeadlineTime *big.Int
	Raw                    types.Log // Blockchain specific contextual infos
}

// FilterReportSubmitted is a free log retrieval operation binding the contract event 0xaed7d1a7a1831158dcda1e4214f5862f450bd3eb5721a5f322bf8c9fe1790b0a.
//
// Solidity: event ReportSubmitted(uint256 indexed refSlot, bytes32 hash, uint256 processingDeadlineTime)
func (_Vebo *VeboFilterer) FilterReportSubmitted(opts *bind.FilterOpts, refSlot []*big.Int) (*VeboReportSubmittedIterator, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "ReportSubmitted", refSlotRule)
	if err != nil {
		return nil, err
	}
	return &VeboReportSubmittedIterator{contract: _Vebo.contract, event: "ReportSubmitted", logs: logs, sub: sub}, nil
}

// WatchReportSubmitted is a free log subscription operation binding the contract event 0xaed7d1a7a1831158dcda1e4214f5862f450bd3eb5721a5f322bf8c9fe1790b0a.
//
// Solidity: event ReportSubmitted(uint256 indexed refSlot, bytes32 hash, uint256 processingDeadlineTime)
func (_Vebo *VeboFilterer) WatchReportSubmitted(opts *bind.WatchOpts, sink chan<- *VeboReportSubmitted, refSlot []*big.Int) (event.Subscription, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "ReportSubmitted", refSlotRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboReportSubmitted)
				if err := _Vebo.contract.UnpackLog(event, "ReportSubmitted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseReportSubmitted is a log parse operation binding the contract event 0xaed7d1a7a1831158dcda1e4214f5862f450bd3eb5721a5f322bf8c9fe1790b0a.
//
// Solidity: event ReportSubmitted(uint256 indexed refSlot, bytes32 hash, uint256 processingDeadlineTime)
func (_Vebo *VeboFilterer) ParseReportSubmitted(log types.Log) (*VeboReportSubmitted, error) {
	event := new(VeboReportSubmitted)
	if err := _Vebo.contract.UnpackLog(event, "ReportSubmitted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboResumedIterator is returned from FilterResumed and is used to iterate over the raw logs and unpacked data for Resumed events raised by the Vebo contract.
type VeboResumedIterator struct {
	Event *VeboResumed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboResumedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboResumed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboResumed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboResumedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboResumedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboResumed represents a Resumed event raised by the Vebo contract.
type VeboResumed struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterResumed is a free log retrieval operation binding the contract event 0x62451d457bc659158be6e6247f56ec1df424a5c7597f71c20c2bc44e0965c8f9.
//
// Solidity: event Resumed()
func (_Vebo *VeboFilterer) FilterResumed(opts *bind.FilterOpts) (*VeboResumedIterator, error) {

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "Resumed")
	if err != nil {
		return nil, err
	}
	return &VeboResumedIterator{contract: _Vebo.contract, event: "Resumed", logs: logs, sub: sub}, nil
}

// WatchResumed is a free log subscription operation binding the contract event 0x62451d457bc659158be6e6247f56ec1df424a5c7597f71c20c2bc44e0965c8f9.
//
// Solidity: event Resumed()
func (_Vebo *VeboFilterer) WatchResumed(opts *bind.WatchOpts, sink chan<- *VeboResumed) (event.Subscription, error) {

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "Resumed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboResumed)
				if err := _Vebo.contract.UnpackLog(event, "Resumed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseResumed is a log parse operation binding the contract event 0x62451d457bc659158be6e6247f56ec1df424a5c7597f71c20c2bc44e0965c8f9.
//
// Solidity: event Resumed()
func (_Vebo *VeboFilterer) ParseResumed(log types.Log) (*VeboResumed, error) {
	event := new(VeboResumed)
	if err := _Vebo.contract.UnpackLog(event, "Resumed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the Vebo contract.
type VeboRoleAdminChangedIterator struct {
	Event *VeboRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboRoleAdminChanged represents a RoleAdminChanged event raised by the Vebo contract.
type VeboRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_Vebo *VeboFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*VeboRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &VeboRoleAdminChangedIterator{contract: _Vebo.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_Vebo *VeboFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *VeboRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboRoleAdminChanged)
				if err := _Vebo.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_Vebo *VeboFilterer) ParseRoleAdminChanged(log types.Log) (*VeboRoleAdminChanged, error) {
	event := new(VeboRoleAdminChanged)
	if err := _Vebo.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the Vebo contract.
type VeboRoleGrantedIterator struct {
	Event *VeboRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboRoleGranted represents a RoleGranted event raised by the Vebo contract.
type VeboRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_Vebo *VeboFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*VeboRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &VeboRoleGrantedIterator{contract: _Vebo.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_Vebo *VeboFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *VeboRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboRoleGranted)
				if err := _Vebo.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_Vebo *VeboFilterer) ParseRoleGranted(log types.Log) (*VeboRoleGranted, error) {
	event := new(VeboRoleGranted)
	if err := _Vebo.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the Vebo contract.
type VeboRoleRevokedIterator struct {
	Event *VeboRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboRoleRevoked represents a RoleRevoked event raised by the Vebo contract.
type VeboRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_Vebo *VeboFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*VeboRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &VeboRoleRevokedIterator{contract: _Vebo.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_Vebo *VeboFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *VeboRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboRoleRevoked)
				if err := _Vebo.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_Vebo *VeboFilterer) ParseRoleRevoked(log types.Log) (*VeboRoleRevoked, error) {
	event := new(VeboRoleRevoked)
	if err := _Vebo.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboValidatorExitRequestIterator is returned from FilterValidatorExitRequest and is used to iterate over the raw logs and unpacked data for ValidatorExitRequest events raised by the Vebo contract.
type VeboValidatorExitRequestIterator struct {
	Event *VeboValidatorExitRequest // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboValidatorExitRequestIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboValidatorExitRequest)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboValidatorExitRequest)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboValidatorExitRequestIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboValidatorExitRequestIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboValidatorExitRequest represents a ValidatorExitRequest event raised by the Vebo contract.
type VeboValidatorExitRequest struct {
	StakingModuleId *big.Int
	NodeOperatorId  *big.Int
	ValidatorIndex  *big.Int
	ValidatorPubkey []byte
	Timestamp       *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterValidatorExitRequest is a free log retrieval operation binding the contract event 0x96395f55c4997466e5035d777f0e1ba82b8cae217aaad05cf07839eb7c75bcf2.
//
// Solidity: event ValidatorExitRequest(uint256 indexed stakingModuleId, uint256 indexed nodeOperatorId, uint256 indexed validatorIndex, bytes validatorPubkey, uint256 timestamp)
func (_Vebo *VeboFilterer) FilterValidatorExitRequest(opts *bind.FilterOpts, stakingModuleId []*big.Int, nodeOperatorId []*big.Int, validatorIndex []*big.Int) (*VeboValidatorExitRequestIterator, error) {

	var stakingModuleIdRule []interface{}
	for _, stakingModuleIdItem := range stakingModuleId {
		stakingModuleIdRule = append(stakingModuleIdRule, stakingModuleIdItem)
	}
	var nodeOperatorIdRule []interface{}
	for _, nodeOperatorIdItem := range nodeOperatorId {
		nodeOperatorIdRule = append(nodeOperatorIdRule, nodeOperatorIdItem)
	}
	var validatorIndexRule []interface{}
	for _, validatorIndexItem := range validatorIndex {
		validatorIndexRule = append(validatorIndexRule, validatorIndexItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "ValidatorExitRequest", stakingModuleIdRule, nodeOperatorIdRule, validatorIndexRule)
	if err != nil {
		return nil, err
	}
	return &VeboValidatorExitRequestIterator{contract: _Vebo.contract, event: "ValidatorExitRequest", logs: logs, sub: sub}, nil
}

// WatchValidatorExitRequest is a free log subscription operation binding the contract event 0x96395f55c4997466e5035d777f0e1ba82b8cae217aaad05cf07839eb7c75bcf2.
//
// Solidity: event ValidatorExitRequest(uint256 indexed stakingModuleId, uint256 indexed nodeOperatorId, uint256 indexed validatorIndex, bytes validatorPubkey, uint256 timestamp)
func (_Vebo *VeboFilterer) WatchValidatorExitRequest(opts *bind.WatchOpts, sink chan<- *VeboValidatorExitRequest, stakingModuleId []*big.Int, nodeOperatorId []*big.Int, validatorIndex []*big.Int) (event.Subscription, error) {

	var stakingModuleIdRule []interface{}
	for _, stakingModuleIdItem := range stakingModuleId {
		stakingModuleIdRule = append(stakingModuleIdRule, stakingModuleIdItem)
	}
	var nodeOperatorIdRule []interface{}
	for _, nodeOperatorIdItem := range nodeOperatorId {
		nodeOperatorIdRule = append(nodeOperatorIdRule, nodeOperatorIdItem)
	}
	var validatorIndexRule []interface{}
	for _, validatorIndexItem := range validatorIndex {
		validatorIndexRule = append(validatorIndexRule, validatorIndexItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "ValidatorExitRequest", stakingModuleIdRule, nodeOperatorIdRule, validatorIndexRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboValidatorExitRequest)
				if err := _Vebo.contract.UnpackLog(event, "ValidatorExitRequest", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseValidatorExitRequest is a log parse operation binding the contract event 0x96395f55c4997466e5035d777f0e1ba82b8cae217aaad05cf07839eb7c75bcf2.
//
// Solidity: event ValidatorExitRequest(uint256 indexed stakingModuleId, uint256 indexed nodeOperatorId, uint256 indexed validatorIndex, bytes validatorPubkey, uint256 timestamp)
func (_Vebo *VeboFilterer) ParseValidatorExitRequest(log types.Log) (*VeboValidatorExitRequest, error) {
	event := new(VeboValidatorExitRequest)
	if err := _Vebo.contract.UnpackLog(event, "ValidatorExitRequest", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboWarnDataIncompleteProcessingIterator is returned from FilterWarnDataIncompleteProcessing and is used to iterate over the raw logs and unpacked data for WarnDataIncompleteProcessing events raised by the Vebo contract.
type VeboWarnDataIncompleteProcessingIterator struct {
	Event *VeboWarnDataIncompleteProcessing // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboWarnDataIncompleteProcessingIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboWarnDataIncompleteProcessing)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboWarnDataIncompleteProcessing)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboWarnDataIncompleteProcessingIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboWarnDataIncompleteProcessingIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboWarnDataIncompleteProcessing represents a WarnDataIncompleteProcessing event raised by the Vebo contract.
type VeboWarnDataIncompleteProcessing struct {
	RefSlot           *big.Int
	RequestsProcessed *big.Int
	RequestsCount     *big.Int
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterWarnDataIncompleteProcessing is a free log retrieval operation binding the contract event 0xefc67aab43195093a8d8ed25d52281d96de480748ece2787888c586e8e1e79b4.
//
// Solidity: event WarnDataIncompleteProcessing(uint256 indexed refSlot, uint256 requestsProcessed, uint256 requestsCount)
func (_Vebo *VeboFilterer) FilterWarnDataIncompleteProcessing(opts *bind.FilterOpts, refSlot []*big.Int) (*VeboWarnDataIncompleteProcessingIterator, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "WarnDataIncompleteProcessing", refSlotRule)
	if err != nil {
		return nil, err
	}
	return &VeboWarnDataIncompleteProcessingIterator{contract: _Vebo.contract, event: "WarnDataIncompleteProcessing", logs: logs, sub: sub}, nil
}

// WatchWarnDataIncompleteProcessing is a free log subscription operation binding the contract event 0xefc67aab43195093a8d8ed25d52281d96de480748ece2787888c586e8e1e79b4.
//
// Solidity: event WarnDataIncompleteProcessing(uint256 indexed refSlot, uint256 requestsProcessed, uint256 requestsCount)
func (_Vebo *VeboFilterer) WatchWarnDataIncompleteProcessing(opts *bind.WatchOpts, sink chan<- *VeboWarnDataIncompleteProcessing, refSlot []*big.Int) (event.Subscription, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "WarnDataIncompleteProcessing", refSlotRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboWarnDataIncompleteProcessing)
				if err := _Vebo.contract.UnpackLog(event, "WarnDataIncompleteProcessing", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWarnDataIncompleteProcessing is a log parse operation binding the contract event 0xefc67aab43195093a8d8ed25d52281d96de480748ece2787888c586e8e1e79b4.
//
// Solidity: event WarnDataIncompleteProcessing(uint256 indexed refSlot, uint256 requestsProcessed, uint256 requestsCount)
func (_Vebo *VeboFilterer) ParseWarnDataIncompleteProcessing(log types.Log) (*VeboWarnDataIncompleteProcessing, error) {
	event := new(VeboWarnDataIncompleteProcessing)
	if err := _Vebo.contract.UnpackLog(event, "WarnDataIncompleteProcessing", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// VeboWarnProcessingMissedIterator is returned from FilterWarnProcessingMissed and is used to iterate over the raw logs and unpacked data for WarnProcessingMissed events raised by the Vebo contract.
type VeboWarnProcessingMissedIterator struct {
	Event *VeboWarnProcessingMissed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *VeboWarnProcessingMissedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(VeboWarnProcessingMissed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(VeboWarnProcessingMissed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *VeboWarnProcessingMissedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *VeboWarnProcessingMissedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// VeboWarnProcessingMissed represents a WarnProcessingMissed event raised by the Vebo contract.
type VeboWarnProcessingMissed struct {
	RefSlot *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterWarnProcessingMissed is a free log retrieval operation binding the contract event 0x800b849c8bf80718cf786c99d1091c079fe2c5e420a3ba7ba9b0ef8179ef2c38.
//
// Solidity: event WarnProcessingMissed(uint256 indexed refSlot)
func (_Vebo *VeboFilterer) FilterWarnProcessingMissed(opts *bind.FilterOpts, refSlot []*big.Int) (*VeboWarnProcessingMissedIterator, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.FilterLogs(opts, "WarnProcessingMissed", refSlotRule)
	if err != nil {
		return nil, err
	}
	return &VeboWarnProcessingMissedIterator{contract: _Vebo.contract, event: "WarnProcessingMissed", logs: logs, sub: sub}, nil
}

// WatchWarnProcessingMissed is a free log subscription operation binding the contract event 0x800b849c8bf80718cf786c99d1091c079fe2c5e420a3ba7ba9b0ef8179ef2c38.
//
// Solidity: event WarnProcessingMissed(uint256 indexed refSlot)
func (_Vebo *VeboFilterer) WatchWarnProcessingMissed(opts *bind.WatchOpts, sink chan<- *VeboWarnProcessingMissed, refSlot []*big.Int) (event.Subscription, error) {

	var refSlotRule []interface{}
	for _, refSlotItem := range refSlot {
		refSlotRule = append(refSlotRule, refSlotItem)
	}

	logs, sub, err := _Vebo.contract.WatchLogs(opts, "WarnProcessingMissed", refSlotRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(VeboWarnProcessingMissed)
				if err := _Vebo.contract.UnpackLog(event, "WarnProcessingMissed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWarnProcessingMissed is a log parse operation binding the contract event 0x800b849c8bf80718cf786c99d1091c079fe2c5e420a3ba7ba9b0ef8179ef2c38.
//
// Solidity: event WarnProcessingMissed(uint256 indexed refSlot)
func (_Vebo *VeboFilterer) ParseWarnProcessingMissed(log types.Log) (*VeboWarnProcessingMissed, error) {
	event := new(VeboWarnProcessingMissed)
	if err := _Vebo.contract.UnpackLog(event, "WarnProcessingMissed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
